<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[js对象的深入理解]]></title>
      <url>http://yoursite.com/2016/07/13/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="JavaScript作为一门非常灵活的动态语言，可以有许多不同的编程范式，而面向对象也是其中之一，但是对比传统的面向对象语言，Js有着很多不同，比如原型链的继承方式等等。由于很多容易混淆的概率问题，这篇文章总结一下我在学习和实践当中对js对象的理解。"><a href="#JavaScript作为一门非常灵活的动态语言，可以有许多不同的编程范式，而面向对象也是其中之一，但是对比传统的面向对象语言，Js有着很多不同，比如原型链的继承方式等等。由于很多容易混淆的概率问题，这篇文章总结一下我在学习和实践当中对js对象的理解。" class="headerlink" title="JavaScript作为一门非常灵活的动态语言，可以有许多不同的编程范式，而面向对象也是其中之一，但是对比传统的面向对象语言，Js有着很多不同，比如原型链的继承方式等等。由于很多容易混淆的概率问题，这篇文章总结一下我在学习和实践当中对js对象的理解。"></a>JavaScript作为一门非常灵活的动态语言，可以有许多不同的编程范式，而面向对象也是其中之一，但是对比传统的面向对象语言，Js有着很多不同，比如原型链的继承方式等等。由于很多容易混淆的概率问题，这篇文章总结一下我在学习和实践当中对js对象的理解。</h3><a id="more"></a>
<h6 id="从刀耕火种到工程化开发，从es5到es2015-，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。"><a href="#从刀耕火种到工程化开发，从es5到es2015-，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。" class="headerlink" title="从刀耕火种到工程化开发，从es5到es2015+，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。"></a>从刀耕火种到工程化开发，从es5到es2015+，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。</h6><h3 id="一-js里的对象是什么？"><a href="#一-js里的对象是什么？" class="headerlink" title="一. js里的对象是什么？"></a>一. js里的对象是什么？</h3><h4 id="js的七种数据类型："><a href="#js的七种数据类型：" class="headerlink" title="js的七种数据类型："></a>js的七种数据类型：</h4><p>基本数据类型：Undefined,Null,Boolean,Number,String，Symbol(es6新增);</p>
<p>引用数据类型：Object</p>
<h5 id="它们之间的联系："><a href="#它们之间的联系：" class="headerlink" title="它们之间的联系："></a>它们之间的联系：</h5><p>我们有一个typeof操作符可以判断数据类型，有两个特性情况：</p>
<pre><code>typeof null //object
typeof function //function
</code></pre><p>可见虽然null是一种基本类型值，但是它表示空的对象引用，这里就有个问题：</p>
<p>对象为空和空对象引用的区别？</p>
<h6 id="对象为空"><a href="#对象为空" class="headerlink" title="对象为空:"></a>对象为空:</h6><pre><code>let obj = {};
</code></pre><p>看似空空，其实非也，不要忘了，这个对象是继承自Object类型的，而Object原型上又有许多方法和属性，比如toString()等；</p>
<h6 id="空对象引用："><a href="#空对象引用：" class="headerlink" title="空对象引用："></a>空对象引用：</h6><p>可以类比C/C++的空指针吧，没有任何指向</p>
<p>你经常会看到：</p>
<pre><code>const str = &apos;hello luoxia&apos;s blog&apos;;
console.log(str.length);
</code></pre><p>你会想，奇了怪了，这个str明明是基本数据类型啊，并非对象，为何它会有length属性呢？<br>听我慢慢道来：</p>
<p>我们在访问str的length属性时，其实内部机制是这样的：</p>
<ol>
<li>创建String基本包装类型的实例；</li>
<li>在实例上调用这个方法</li>
<li>销毁这个实例</li>
</ol>
<p>这你就应该明白了，并不是说str就是对象，而是内部调用了它的基本包装类型实例，基本包装类型实例是对象，当然有属性和方法了。就好比 2.toString();并不是说2是对象，而是它的基本包装类型Number类型的作用呢</p>
<h6 id="js中一切皆对象，我的理解："><a href="#js中一切皆对象，我的理解：" class="headerlink" title="js中一切皆对象，我的理解："></a>js中一切皆对象，我的理解：</h6><p>对于Object类型毫无疑问，js中数组，函数都是对象，比如数组对象：</p>
<pre><code>const arr = [1,0,2,4]
//等价于:{
    0:1,
    1:0,
    2:2,
    3:4,
    length:4
    }
</code></pre><p>而对于基本类型的值，就像刚刚说的，并不是说2就是对象，而是说我吗可以利用他的包装类型对它进行一系列的属性和方法的访问。</p>
<p>对于es6新增的symbol值，我现在还有个疑问，Symbol值非对象，但是它也有一系列方法和属性，则不就类似的表面它也有其包装类型，那么这个包装类型是什么呢？Symbol? No,我们在创建Symbol值的时候是这样子的：</p>
<pre><code>let sy = Symbol(&apos;describtion&apos;);
</code></pre><p>可以看到并不能new Symbol创建基本包装类型</p>
<h3 id="二-让我们一起new对象吧（这个我的理解就是封装）"><a href="#二-让我们一起new对象吧（这个我的理解就是封装）" class="headerlink" title="二. 让我们一起new对象吧（这个我的理解就是封装）"></a>二. 让我们一起new对象吧（这个我的理解就是封装）</h3><h4 id="两种方式："><a href="#两种方式：" class="headerlink" title="两种方式："></a>两种方式：</h4><ol>
<li><p>new+构造函数+()</p>
<pre><code>let obj = new Object();
</code></pre></li>
<li><p>对象字面量</p>
<pre><code>let obj = {
    name:&apos;luoxia&apos;
    }
</code></pre></li>
</ol>
<p>这个构造函数可以是语言本身就有的，就比如Number这个基本包装类型，也可以是自定义的构造函数，而我要讲的主要是自己定义的构造函数，毕竟在实际应用中，往往需要自定义类型满足需求。</p>
<p>es5及之前版本，js是没有class(类）的说法的，不想java那种，es当中只有构造函数的概念，这在开始，是有些难以理解的，es2015当中，新增了class关键字，但其内部的原理，比如原型继承都是类似的，只是加了语法糖便于更好的理解而已。</p>
<h4 id="创建对象："><a href="#创建对象：" class="headerlink" title="创建对象："></a>创建对象：</h4><p>先举个栗子</p>
<pre><code>function Obj(name,age){
    this.name= name;
    this.age = age;
    this.sayName = function(){
        console.log(this.name);
    }
}
var obj1 = new Obj(&apos;luoxia&apos;,19);
var obj2 = new Obj(&apos;Jane&apos;,18);
......
</code></pre><p>这个和java某个类中的构造函数是那么的相似：</p>
<pre><code>public class Obj {
    private String name;
    private Int age;
    Obj(String name,int age){
        this.name = name;
        this.age = age;
    }
    public void sayName(){
        System.out.println(this.name);
    }
}
</code></pre><p>js的构造函数可以在this对象上直接加方法哎。。。这是外观上的差别，而理解js对象，关键是要理解两个核心：原型对象和原型链，而原型链是继承的实现机制，我们先来看看原型对象：</p>
<h5 id="原型对象："><a href="#原型对象：" class="headerlink" title="原型对象："></a>原型对象：</h5><p>这个东西最好是有图解，但是好麻烦，我还是总结一下我的理解算了吧，需要图解的可以看书或者其它文章</p>
<p>对于任意一个构造函数（函数），就如上例的Obj,函数也是对象，而函数会自动拥有一个属性，那便是prototype属性，它的值是一个指针，这个指针指向哪里呢，指向的便是这个函数的原型对象，prototype，这个原型对象拥有一个默认的属性constructor,其指向原型对象的拥有者，即构造函数本身:</p>
<pre><code>console.log(Obj.prototype.constructor)//Obj
</code></pre><p>上述的构造函数的this指向哪里呢？this的话题又是一个很多坑的话题，this的定义本来就是函数赖以执行的环境，当我们通过构造函数实例化一个对象的时候，这个this就指向了这个实例对象，这个实例对象就拥有了上例中初始化的属性和方法，而这些属性和方法都在哪里呢？就是在实例对象上，</p>
<p>对，没错，这些属性和方法由于通过构造函数的方式初始化，当new Obj()的时候，便初始化给了实例对象，而除了这些自定义初始化的属性和方法，实例对象内部有一个属性：__proto__，这个属性的值也是一个指针，它指向了构造函数的原型对象prototype:</p>
<pre><code>console.log(obj1.__proto__)//Obj.prototype
</code></pre><p>下面几个情形:</p>
<pre><code>Object.__proto__//Function.prototype
Function.__proto__//Function.prototype
Function.prototype.__proto__//Object.prototype
Object.prototype.__proto__//null
</code></pre><p>可见，Object构造函数是Function的实例，而Function的原型对象又是Object的实例，即Function继承于Object，任何构造函数，其本身作为对象，它们都是Function的实例，当然__proto__指向Function</p>
<p>我们会发现，基于构造函数的方式创建对象有一个不足，那就是对于一些公用的方法和属性，我们在实例化不同的对象时，会创建多个本来可以公用的方法，这不就是一种浪费吗？</p>
<p>再来看看下面的例子：</p>
<pre><code>function Obj2(){
}
Obj2.prototype.name = &apos;luoxia&apos;;
Obj2.prototype.age = 19;
Obj2.prototype.sayname = function (){
    console.log(this.name);
}
</code></pre><p>这个便是基于原型的方式创建对象，所谓基于原型，便是将属性和方法初始化给构造函数的原型对象，而所有通过这个构造函数实例化的对象将共享这些属性和方法，共享有木有，这就有一个问题：</p>
<pre><code>Obj2.prototype.arr = [1,2,3];
let obj1 = new Obj2();
let obj2 = new Obj2();
obj1.arr.push(4);
console.log(obj2.arr);//[1,2,3,4]
</code></pre><p>有没有发现，两个不同的实例，对一个实例的数据修改，本来不应该反映到另一个实例，但由于它们共享了这个数组的引用，这就导致它们互相牵连，所以，这也是原型创建对象方法的一个不足。</p>
<p>其中有一个问题要注意，当用对象字面量改变构造函数的原型对象时，会改写原型对象的 constructor属性指向：</p>
<pre><code>Obj2.prototype = {
    name:&apos;luoxia&apos;,
    age:19
}
console.log(Obj2.prototype.constructor)//Object
</code></pre><p>本该如此，因为此时的原型对象本来就是Object的实例</p>
<p>我们可以手动的设置它的constructor属性为构造函数</p>
<h4 id="创建对象的几种模式"><a href="#创建对象的几种模式" class="headerlink" title="创建对象的几种模式"></a>创建对象的几种模式</h4><ol>
<li>工厂模式，即在一个函数内部新建一个对象，初始化后返回这个对象，封装内部细节，返回，但是这个模式是无法识别对象类型的。。。</li>
<li>构造函数模式，上例</li>
<li>原型模式，上例</li>
<li>组合使用构造函数模式和原型模式:</li>
</ol>
<p>可见，构造函数模式和原型模式都有自己的不足，我们可以组合使用它们，这个模式也是最常用的模式:</p>
<pre><code>function Person(name,age){
    this.name = name;
    this.age = age;
    this.arr = [name,age];
}
Person.prototype.sayname = function(){
    console.log(this.name);
}
let person1 = new Person(&apos;luoxia&apos;,19);
let person2 = new Person(&apos;jane&apos;,18);
person1.arr.push(&apos;add&apos;);
console.log(person2.arr)//[&apos;jane&apos;,18];
</code></pre><p>我们将公用的sayname方法初始化到原型对象上，将实例属性（包括一些引用类型的属性）初始化到实例对象上，可见，各个实例属性的引用类型就不会互相影响了。</p>
<p>这个模式既做到了公共方法和属性的 共享，又做到了私有属性的互不干扰，而且还可以通过构造函数传递参数，这确实是一个不错的创建对象模式。</p>
<ol>
<li>其他模式：动态原型模式，寄生构造函数模式，稳妥构造函数模式，适用于特定场景。</li>
</ol>
<h3 id="三-继承"><a href="#三-继承" class="headerlink" title="三.继承"></a>三.继承</h3><p>js的继承和其他语言不同，她是基于原型链的继承。用个例子说话：</p>
<pre><code>function Super(){
    this.superName = &apos;super&apos;;
}
function Sub(){
    this.subName = &apos;sub&apos;;
}
Sub.prototype = new Super();
let super = new Super();
let sub = new Sub();
console.log(sub.superName);//super
</code></pre><p>这就是一个继承的例子，Sub的原型对象是Super的实例，这样，在Super实例对象的属性就成为了Sub原型对象的属性，Sub的实例就可以对它进行访问，而此时Super原型对象就有了一个内部属性<strong>proto</strong>指向了Super的原型对象，而subName属性存在于Sub的实例对象当中。</p>
<p>这样一层层的继承，便形成了一条原型链，处于顶端的是Object类型。</p>
<p>上述例子便是继承的一种模式，基于原型链的模式，这个存在一个类似于原型创建对象模式的问题,那便是引用类型的互相影响:</p>
<pre><code>function Super(){
    this.arr = [1,2,3];
}
function Sub(){

}
Sub.prototype = new Super();
let sub1 = new Sub();
let sub2 = new Sub();
sub1.arr.push(4);
console.log(sub2.arr);//[1,2,3,4];
</code></pre><p>发现子类型的两个不同实例的引用类型即这里的数组值会互相影响，这是由于这个数组属性是存在于Sub原型对象内的，这样Sub实例对象就共享了这个数组，当然会互相影响。</p>
<h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h4><ol>
<li>原型链的方式，上例；</li>
<li>借用构造函数:</li>
</ol>
<pre><code>function Super(){
    this.arr = [1,2,3];
}
function Sub(){
    Super.apply(this);
}
let sub1 = new Sub();
let sub2 = new Sub();
sub1.arr.push(4);
console.log(sub2.arr);//[1,2,3];
</code></pre><p>原理就是在new Sub()的时候，实际上是执行了内部的Super.apply(this)，这样Super函数执行，内部的this又指向的是Sub的实例对象，自然而然的就让所有父类型构造函数的属性和方法给了子类实例，但是这个方式如同构造函数模式创建对象一样，无法公用属性和方法，浪费。</p>
<ol>
<li>组合继承:</li>
</ol>
<p>可以这么想，和组合方式的创建对象模式类似的思想。</p>
<pre><code>function Super(){
    this.arr = [1,2,3];
}
Super.prototype.sayName(){
    console.log(&apos;luoxia&apos;);
}
function Sub(){
    Super.apply(this);
}
Sub.prototype = new Super();
let sub1 = new Sub();
let sub2 = new Sub();
sub1.arr.push(4);
console.log(sub2.arr);//[1,2,3];
</code></pre><p>看看上面的例子，内部机制是如何的?我们让Sub的原型对象等于Super的实例，这样Super构造函数定义的属性就存在于Sub的原型对象上，而Super.apply(this)则让Super构造函数再次执行，而这时，this指向的是Sub实例对象，所以Super构造函数的属性就存在于实例对象上了，好嘞，这下在Sub原型对象上有个arr属性，在Sub的实例上有个arr属性，由于实例上的同名属性会优先于原型对象上的属性，这样我们访问的就是实例的属性了，当然互不影响，而且对于不同的Sub实例，它们现在都可以访问sayName方法了，因为这个方法存在于Super的原型对象中，可以共享。</p>
<ol>
<li><p>原型式继承，即Object.create()</p>
<pre><code>let obj = Object.create({name:&apos;luoxia&apos;});
</code></pre></li>
</ol>
<p>其实就相当于 </p>
<pre><code>function object(o){
    let obj = {};
    obj.__proto__ = o;
}
let obj = object();
</code></pre><p>就是将参数对象作为子类型的<strong>proto</strong>值，好比其构造函数的原型对象。这个对于引用类型的属性，同样会互相影响</p>
<ol>
<li>寄生式继承，和原型式类似，不过是在内部对新对象加了一些扩展再返回而已。</li>
</ol>
<ol>
<li>寄生组合继承:</li>
</ol>
<p>这个是对组合继承方式的一种改良，在前面的组合继承方式中,存在一个不足，那便是我们既在子类型的原型对象上创建了属性，又在实例对象上创建了同名属性，那么原型对象上的那些属性岂不是浪费时间浪费金钱的产物？而这个方式就是解决这个问题的：</p>
<pre><code>function inheritPrototype(sub,super){
    let prototype = object(super.prototype);
    prototype.constructor = sub;
    sub.prototype = prototype;
}


function Sup(){
    this.arr = [1,2,3];
}
Sup.prototype.sayName(){
    console.log(&apos;luoxia&apos;);
}
function Sub(){
    Sup.apply(this);
}
inheritPrototype(Sub,Sup); //实际上相当于Sub.prototype.__proto__ = Sup.prototype
let sub1 = new Sub();
let sub2 = new Sub();
sub1.arr.push(4);
console.log(sub2.arr);//[1,2,3];
</code></pre><p>大家可以看到，这个例子并没有显式地设置Sub的原型对象，而是将Super的原型对象复制了一份给Sub，这样的话在Super实例上的属性当然不会跑到Sub上了，这个模式最理想。</p>
<h3 id="四-多态"><a href="#四-多态" class="headerlink" title="四.多态"></a>四.多态</h3><p>在java中，所谓多态，便是某个对象既属于子类型，又属于父类型，js中也有类似的概率，instanceof操作符就是用来判断实例和原型的关系：</p>
<pre><code>console.log(sub1 instanceof Object);//true
console.log(sub1 instaceof Sub);//true
console.log(sub1 instanceof Super);//true
</code></pre><p>可见，sub1是属于子类型，父类型，也是Object类型的</p>
<h3 id="五-ES2015当中的Class及继承"><a href="#五-ES2015当中的Class及继承" class="headerlink" title="五.ES2015当中的Class及继承"></a>五.ES2015当中的Class及继承</h3><p>直接上栗子：</p>
<pre><code>class A{
    constructor(name){
        this.name = name;
    }
    get test(){
        return this.name;
    }
    set test(name){
        this.name = name;
        return &apos;setter&apos;;
    }
}
class B extends A{
    constructor(name,age){
        super(name);
        this.age = age;
    }
    static sayAge(){
        console.log(&apos;age&apos;);
    }
}
let b = new B(&apos;luoxia&apos;,20);
let a = new A(&apos;jane&apos;);
console.log(b.test);//luoxia
b.test = &apos;jack&apos;;
console.log(b.test);//jack
console.log(B.sayAge);//age
</code></pre><h4 id="class的对象创建："><a href="#class的对象创建：" class="headerlink" title="class的对象创建："></a>class的对象创建：</h4><p>es2015中的class的类型就是function,但是不能直接执行，只能new实例，而constructor就是它的构造函数，即es5中的构造函数就好比es2015 clss的constructor。</p>
<p>虽然加了语法糖，其实内部机制类似，class内的方法（非this指定）的都会存在于类的原型对象上，即上述class A：</p>
<pre><code>A.prototype = {
    get test(){
        ...
    }
    ...
}
console.log(b.constructor === B.prototype.constructor);//true
console.log(B === B.prototype.constructor);//true
console.log(b.__proto__);//B.prototype
</code></pre><p>而通过构造函数初始化的属性和方法存在于类的实例化对象上</p>
<h4 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h4><p>class的继承其内部还是原型的继承，不过有区别</p>
<p>上例中，A和B存在两条继承关系：</p>
<p>类作为对象的时候：</p>
<pre><code>B.__proto__ = A;
</code></pre><p>作为构造函数：</p>
<pre><code>B.prototype.__proto__ = A.prototype;
</code></pre><p>主要是由于在创建实例的时候，内部是这样运行的：</p>
<pre><code>// B的实例继承A的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B继承A的静态属性（方法）（static，即直接通过类名调用）
Object.setPrototypeOf(B, A);
</code></pre><p>经过检验：</p>
<pre><code>console.log(b.hasOwnProperty(&apos;name&apos;));//true
console.log(b.__proto__.hasOwnProperty(&apos;name&apos;));//false
</code></pre><p>说明name是存在于b实例对象上的,B的原型对象上没有这个name属性。</p>
<h4 id="es2015和es5继承的联系"><a href="#es2015和es5继承的联系" class="headerlink" title="es2015和es5继承的联系"></a>es2015和es5继承的联系</h4><p>发现它们的联系了吗？前面讲es5的继承方式有个组合继承方式和寄生组合方式，两种的区别就在于，组合继承方式会在子类型原型上创建多余的属性，而后者，我也在代码里说过，其实质就是设置：</p>
<pre><code>Sub.prototype.__proto__ = Sup.prototype
</code></pre><p>而这个，正好是es2015 class的继承关系。</p>
<p>聪明的你会想，我们在</p>
<pre><code>Sub.prototype = new Sup()；
</code></pre><p>时不就是让Sub.prototype.<strong>proto</strong>等于Sup.prototype吗，没错，其结果确实是这样，但是用new的时候我们就执行了构造函数，让内部实例属性存在于prototype里了，而我们直接设置Sub.prototype.<strong>proto</strong> = Sup.prototype只是创建prototype的实例</p>
<h4 id="es5和es2015继承的区别："><a href="#es5和es2015继承的区别：" class="headerlink" title="es5和es2015继承的区别："></a>es5和es2015继承的区别：</h4><ol>
<li>对于父类型的构造函数，es5通过apply()或者call()方法指定其在子类型的实例上运行，这里是先有子类型实例的this,再去调用父类型构造函数的，而es2015就不一样了，先要通过super()的运行，才有this,即子类型的构造函数内的this是父类型构造函数给与的，指向子类型实例，所以必须先调用super，才能使用this</li>
<li><p>es5子类型实例的constuctor默认指向的是父类型构造函数，而es2015指向子类型构造函数：</p>
<pre><code>console.log(b.constructor);//Function B
console.log(sub.constructor);//Function Sup
</code></pre></li>
</ol>
<h6 id="es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！"><a href="#es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！" class="headerlink" title="es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！"></a>es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！</h6><h4 id="啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。"><a href="#啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。" class="headerlink" title="啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。"></a>啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法之数组]]></title>
      <url>http://yoursite.com/2016/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="这篇文章是第一篇关于算法与数据结构的文章，有关于数组，后续会有系列性的更新与算法与数据结构有关的文章，其中包括es6的扩展方法"><a href="#这篇文章是第一篇关于算法与数据结构的文章，有关于数组，后续会有系列性的更新与算法与数据结构有关的文章，其中包括es6的扩展方法" class="headerlink" title="这篇文章是第一篇关于算法与数据结构的文章，有关于数组，后续会有系列性的更新与算法与数据结构有关的文章，其中包括es6的扩展方法"></a>这篇文章是第一篇关于算法与数据结构的文章，有关于数组，后续会有系列性的更新与算法与数据结构有关的文章，其中包括es6的扩展方法</h3><a id="more"></a>
<h4 id="1-数组的创建"><a href="#1-数组的创建" class="headerlink" title="1. 数组的创建:"></a>1. 数组的创建:</h4><h5 id="a-构造函数方法"><a href="#a-构造函数方法" class="headerlink" title="a. 构造函数方法"></a>a. 构造函数方法</h5><pre><code>let colors = new Array();
</code></pre><p>传递的参数有两种情况，参数为一个时，表示数组长度，返回空数组，而参数个数大于一，则表示每项的值，这种不同的表现方式有些蛋疼，而es6的Array.of()方法则用一致性的变现方式将一组值生成数组</p>
<h5 id="b-字面量"><a href="#b-字面量" class="headerlink" title="b. 字面量"></a>b. 字面量</h5><pre><code>let colors = [&apos;white&apos;,&apos;red&apos;,&apos;orange&apos;];
</code></pre><p>字面量创建并不自动调用构造函数</p>
<h4 id="2-判断是否为数组"><a href="#2-判断是否为数组" class="headerlink" title="2. 判断是否为数组"></a>2. 判断是否为数组</h4><p>instanceof方法，Array.isArray()方法，前者在多个 全局执行环境的时候，从一个执行全局传给另一个全局则两者具有不同的Array()构造函数，因此不能正确判断。所以通常使用后者，</p>
<p>第三种方法 Object.prototype.toString()方法（不仅限于数组）如:</p>
<pre><code>Object.prototype.toString.call(arr) === &apos;[object Array]&apos;
</code></pre><h4 id="3-遍历读写数组"><a href="#3-遍历读写数组" class="headerlink" title="3. 遍历读写数组"></a>3. 遍历读写数组</h4><h5 id="a-起初，咱们用着非常原始的方法，那便是for循环；"><a href="#a-起初，咱们用着非常原始的方法，那便是for循环；" class="headerlink" title="a.  起初，咱们用着非常原始的方法，那便是for循环；"></a>a.  起初，咱们用着非常原始的方法，那便是for循环；</h5><h5 id="b-由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组"><a href="#b-由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组" class="headerlink" title="b.  由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组:"></a>b.  由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组:</h5><pre><code>for(let index in arr){
    console.log(arr[index]);
}
</code></pre><p>这个方式本身就不是用于数组遍历的，会产生很多问题（具体省略）</p>
<h5 id="c-forEach-function-elment-index-arr-…"><a href="#c-forEach-function-elment-index-arr-…" class="headerlink" title="c. forEach(function(elment,index,arr){…})"></a>c. forEach(function(elment,index,arr){…})</h5><p>不能使用break,continue控制语句</p>
<h5 id="d-ES2015的-for-of循环："><a href="#d-ES2015的-for-of循环：" class="headerlink" title="d. ES2015的 for-of循环："></a>d. ES2015的 for-of循环：</h5><pre><code>for(let num in arr){
    console.log(num)
}
</code></pre><p>当然，for-of循环并不只限于访问数组，还可以访问各种具有遍历器接口的类数组,比如Map类型的结构:</p>
<pre><code>for(let [key,value] of phoneMap){
    console.log(key + &apos;:&quot; + value +&apos;  &apos;);
}
</code></pre><p>用到es6的解构赋值</p>
<h4 id="4-其他类型数据与数组的转换"><a href="#4-其他类型数据与数组的转换" class="headerlink" title="4. 其他类型数据与数组的转换:"></a>4. 其他类型数据与数组的转换:</h4><h5 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串:"></a>数组转换为字符串:</h5><p>a. toString(),toLocaleString(),valueOf()将各项用’,’连接返回字符串</p>
<p>b. 数组实例的join()方法，传入用以连接各项的符号，返回字符串</p>
<h5 id="其他类型转换为数组"><a href="#其他类型转换为数组" class="headerlink" title="其他类型转换为数组:"></a>其他类型转换为数组:</h5><p>a. 字符串的split()方法转换为数组<br>b. Array.prototype.slice.call(obj,0)将类数组转换为真正的数组</p>
<p>c. 更一般的，凡是有遍历器接口，或者具有length属性的类数组对象，通过es6的Array.from()可转换为真正的数组,可接受第二个参数为回调函数，类似map()遍历方法，第三个位执行作用域.并且，Array.from()方法能够正确识别unicode码大于\uFFFF的字符，正确得到字符串长度。</p>
<pre><code>function countSymbols(string) {
  return Array.from(string).length;
}
</code></pre><p>d. 前面讲过的Array.of()方法，将一组值转换为数组，参数个数不同，行为一致<br>e. 扩展运算符…，只能转换具有遍历器接口的数据，不能转换类似数组的对象（即具有length属性的对象):</p>
<pre><code>function func(){
    let arr = [...arguments];//[1,2,3]
}
func(1,2,3);
</code></pre><h4 id="5-查找方法"><a href="#5-查找方法" class="headerlink" title="5. 查找方法"></a>5. 查找方法</h4><p>a. indexOf()和lastIndexOf()返回指定元素的位置，会使用全等操作符(不可以正确判断NaN和NaN,+0和-0的关系)</p>
<p>b. es7的includes()方法，这个如果找到就返回true,但是使用的判断方法并不是全等操作符，可以正确判断NaN和NaN,+0和-0的关系;</p>
<p>c. find()和findIndex()方法，执行传入的回调函数，返回第一个符合条件的项/索引</p>
<h4 id="6-数组的栈，队列方法"><a href="#6-数组的栈，队列方法" class="headerlink" title="6. 数组的栈，队列方法"></a>6. 数组的栈，队列方法</h4><p>a. 栈，后进先出(LIFO)，push()从数组末尾推入任意项，pop()移除最后一项<br>b. 队列，先进先出(FIFO)，shift()从前端移除第一项，push()从末端添加一项<br>c. unshift()从前端增加任意项</p>
<h4 id="7-迭代方法"><a href="#7-迭代方法" class="headerlink" title="7. 迭代方法"></a>7. 迭代方法</h4><p> every(),filter(),forEach(),map(),some()方法，都接受2个参数，要执行的回调函数，以及该函数的执行作用域,而回调函数接受三个参数：项的值，项的索引，数组本身，它们有区别，具体省略</p>
<p>曾经遇到过的一个问题，看下面代码：</p>
<pre><code>function Score(){
    this.scores = [];
}
Score.prototype.add = function(score){
    this.scores.push(score);
};
Score.prototype.showAverage = function(){
    let sum = this.scores.reduce(function(pre,cur){
        return pre+cur;
    });
    console.log(sum*1.0/this.scores.length);
};
let scores = [90,80,70];
let score1 = new Score();
scores.forEach(score1.add);
score1.showAverage();
</code></pre><p>发现can’t read property ‘scores’ of undefined;</p>
<p>因为，在</p>
<p>scores.forEach(score1.add);<br>中，存在一个赋值过程，即把score1.add赋给了forEach的内部参数的过程。所以，它相当于：</p>
<p>var add0 = score1.add;<br>scores.forEach(add0);<br>结果add里面的this就变成了undefined，所以报错了。</p>
<p>这样的话，可以给forEach()方法传入作用域，即Score构造函数</p>
<h4 id="8-排序"><a href="#8-排序" class="headerlink" title="8. 排序"></a>8. 排序</h4><p>a. 重排序方法reverse()，只是简单的将原数组倒序<br>b. sort()方法，接受一个比较函数，从而正确的对数组进行从小到大的排序:</p>
<pre><code>function compare(val1,val2){
    if(val1&lt;value2){
        return -1;
    } else if(val1 &gt; val2){
        return 1;
    } else {
        return 0;    
    }
}
var arr = [0,8,5,15];
console.log(arr.sort(compare));//[0,5,8,15]
</code></pre><p>避免不传参数时，10比5小的情况</p>
<h4 id="9-其他的操作方法"><a href="#9-其他的操作方法" class="headerlink" title="9. 其他的操作方法:"></a>9. 其他的操作方法:</h4><p>a. concat(),先创建一个当前数组的副本，然后将接受到的参数添加到末尾;</p>
<p>b. slice()，返回子数组，接受起始和结束位置，不影响原始数组</p>
<p>c. splice()，最强大的数组方法，任意参数，第1个:要删除项的第一个位置，第2个：删除的项数；<br>第3个以及以后：从第一个参数位置开始要插入的项。利用这个方法可以进行删除，插入，替换等操作，举个栗子:</p>
<pre><code>var colors = [&apos;red&apos;,&apos;white&apos;,&apos;black&apos;,green];
var removed = colors.splice(2,1,&apos;orange&apos;,&apos;purple&apos;);//black
console.log(colors);// red,white,orange,purple,green删除了三项，并从原来第三项位置处开始插入了两项
</code></pre><p>d. reduce()和reduceRight()方法，迭代所有项，返回最终值，直接上栗子:</p>
<pre><code>var arr = [1,0,2,4];
var sum = arr.reduce(function(prev,cur,index,array){
    return prev + cur;
});  //7 计算数组每项的和
</code></pre><p>e. 数组的fill()方法，使用给定值，填充数组:</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]

[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)
// [&apos;a&apos;, 7, &apos;c&apos;]
</code></pre><p>f. 数组的copyWithin()方法</p>
<pre><code>// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]
</code></pre><p>g. 数组实例的entries()，keys()和values()返回遍历器对象，可以用for-of循环遍历</p>
<pre><code>for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre><h4 id="10-数组的空位"><a href="#10-数组的空位" class="headerlink" title="10. 数组的空位:"></a>10. 数组的空位:</h4><p>空位并不等于undefined，es5有许多不一致的表现</p>
<p>forEach(), filter(), every() 和some()都会跳过空位。<br>map()会跳过空位，但会保留这个值<br>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</p>
<p>es6视空位为undefined</p>
<h4 id="11-其他技巧"><a href="#11-其他技巧" class="headerlink" title="11.其他技巧"></a>11.其他技巧</h4><p>a. 数组快速去重：原理是set数据结构成员不重复</p>
<pre><code>let arr = [1,3,3,5,5];
let newArr = [...new Set(arr)];
console.log(newArr);//[1,3,5]
</code></pre><p>对于有字符串之类的情况如何：[1,3,’3’,5,’5’]如果你的目的是要让字符串转换成数值再判断，这也很好办，不过是加了处理函数罢了：</p>
<pre><code>let arr = [1,3,&apos;3&apos;,5,&apos;5&apos;];
let newArr = [...new Set(arr.map(element=&gt;parseInt(element)))];
console.log(newArr);//[1,3,5]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于socket.io的聊天应用]]></title>
      <url>http://yoursite.com/2016/06/01/%E5%9F%BA%E4%BA%8Esocket-io%E7%9A%84%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket-IO是一个完全由JavaScript实现、基于Node-js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了客户端的JavaScript和服务器端的Node-js。"><a href="#WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket-IO是一个完全由JavaScript实现、基于Node-js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了客户端的JavaScript和服务器端的Node-js。" class="headerlink" title="WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了客户端的JavaScript和服务器端的Node.js。"></a>WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了客户端的JavaScript和服务器端的Node.js。</h3><h4 id="本文记录利用socket-io开发聊天室的实践"><a href="#本文记录利用socket-io开发聊天室的实践" class="headerlink" title="本文记录利用socket.io开发聊天室的实践"></a>本文记录利用socket.io开发聊天室的实践</h4><a id="more"></a>
<h5 id="Socket-IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket-IO实现的Polling通信机制包括Adobe-Flash-Socket、AJAX长轮询、AJAX-multipart-streaming、持久Iframe、JSONP轮询等。Socket-IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。"><a href="#Socket-IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket-IO实现的Polling通信机制包括Adobe-Flash-Socket、AJAX长轮询、AJAX-multipart-streaming、持久Iframe、JSONP轮询等。Socket-IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。" class="headerlink" title="Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO实现的Polling通信机制包括Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。"></a>Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO实现的Polling通信机制包括Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。</h5><h4 id="a-需要依赖的模块"><a href="#a-需要依赖的模块" class="headerlink" title="a. 需要依赖的模块"></a>a. 需要依赖的模块</h4><ol>
<li>客户端jquery</li>
<li>express</li>
<li>express的静态文件服务</li>
<li>http模块</li>
<li>socket.io</li>
</ol>
<h5 id="Nodejs服务端server-js"><a href="#Nodejs服务端server-js" class="headerlink" title="Nodejs服务端server.js:"></a>Nodejs服务端server.js:</h5><pre><code>var app = require(&apos;express&apos;)();
var http = require(&apos;http&apos;).Server(app);
var io = require(&apos;socket.io&apos;)(http);
var staticServer = require(&apos;express-static&apos;);
</code></pre><h5 id="客户端引入socket-io包的soket-io-js"><a href="#客户端引入socket-io包的soket-io-js" class="headerlink" title="客户端引入socket.io包的soket.io.js"></a>客户端引入socket.io包的soket.io.js</h5><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="b-客户端-index-html"><a href="#b-客户端-index-html" class="headerlink" title="b. 客户端 index.html"></a>b. 客户端 index.html</h4><h5 id="界面以清新简约为主，此处省略样式代码，最终界面效果如下："><a href="#界面以清新简约为主，此处省略样式代码，最终界面效果如下：" class="headerlink" title="界面以清新简约为主，此处省略样式代码，最终界面效果如下："></a>界面以清新简约为主，此处省略样式代码，最终界面效果如下：</h5><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/chatUI.png" alt="UI"></p>
<h5 id="来看几个客户端socket-io的API"><a href="#来看几个客户端socket-io的API" class="headerlink" title="来看几个客户端socket.io的API:"></a>来看几个客户端socket.io的API:</h5><ol>
<li>io(String url,Obj opts) 暴露于window下，可传入建立连接的url字符串和用于设置连接的对象，如果不设置url,则默认建立到位客户端提供服务的服务器根目录</li>
<li>emmit()事件机制，触发某个事件</li>
</ol>
<h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html:"></a>index.html:</h5><ol>
<li><p>建立连接:</p>
<pre><code>var socket = io();
</code></pre></li>
<li><p>触发服务端用户加入事件join:</p>
<pre><code>socket.emit(&apos;join&apos;,name);
</code></pre></li>
<li><p>消息发送，触发服务端消息发送事件text:</p>
<pre><code>socket.emit(&apos;text&apos;,$(&apos;#msg&apos;).val());
</code></pre></li>
<li><p>监听由服务器当其他用户加入时触发的announcement事件,通知新用户加入:</p>
<pre><code>socket.on(&apos;announcement&apos;,function(msg){
            $(&apos;.otherEnter ul&apos;).append(&apos;&lt;li&gt;&apos;+msg+&apos;&lt;/li&gt;&apos;);
        });
</code></pre></li>
<li><p>监听由服务端当其他用户有消息发送时触发的text事件，将新消息加入显示:</p>
<pre><code>socket.on(&apos;text&apos;,function(content){
            $(&apos;.chatList ul&apos;).append(&apos;&lt;li&gt;&apos;+ content +&apos;&lt;/li&gt;&apos;);
        });
</code></pre></li>
<li><p>自己发的消息要在触发服务器text事件之前显示,因为socket.io广播是默认不给本用户触发指定事件的:</p>
<pre><code>$(&apos;.chatList ul&apos;).append(&apos;&lt;li&gt;&lt;span&gt;me&lt;/span&gt;:&apos;+$(&apos;#msg&apos;).val()+&apos;&lt;/li&gt;&apos;)
            socket.emit(&apos;text&apos;,$(&apos;#msg&apos;).val());
</code></pre></li>
</ol>
<h4 id="c-服务端-server-js"><a href="#c-服务端-server-js" class="headerlink" title="c. 服务端 server.js"></a>c. 服务端 server.js</h4><ol>
<li><p>建立静态文件服务器，用到express-static中间件:</p>
<pre><code>app.use(staticServer(&apos;./&apos;));
app.get(&apos;/&apos;,function(req,res){
    res.render(&apos;index&apos;);
});
http.listen(8068,function(){
    console.log(&quot;Sever has been listened at port 8068&quot;);
});
</code></pre><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/chatServer.png" alt="server"></p>
</li>
<li><p>将http服务绑定到socket.io服务:</p>
<pre><code>var io = require(&apos;socket.io&apos;)(http);
</code></pre></li>
<li><p>监听connection事件，当有新连接时触发:</p>
<pre><code>io.on(&quot;connection&quot;,function(socket){
    console.log(&quot;some on connected&quot;);
}
</code></pre><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/chatconnect.png" alt="connect"></p>
</li>
<li><p>新用户连接:join事件,var total = 0;用于统计在线人数,每次新用户加入，通知其他所有用户，并完成total的更新，这就要用到socket.io的广播了，通过.broadcast来进行广播:</p>
<pre><code>total++;
console.log(name+&quot;joined&quot;);
socket.broadcast.emit(&apos;announcement&apos;,name+&apos; joined in&apos;);
socket.broadcast.emit(&apos;totalChange&apos;,total);  //广播用户总数改变事件
</code></pre></li>
<li><p>当某个链接断开时，需要通知其他用户，total更新,socket.io的disconnect事件，当链接断开时触发:</p>
<pre><code>socket.on(&apos;disconnection&apos;,function(){
        total--;
        console.log(&apos;hi,leave&apos;);
        socket.broadcast.emit(&apos;announcement&apos;,name+&apos; leved away&apos;);
        socket.broadcast.emit(&apos;totalChange&apos;,total);
    });
</code></pre></li>
<li><p>广播聊天内容:</p>
<pre><code>socket.on(&apos;text&apos;,function(msg){
    socket.broadcast.emit(&apos;text&apos;,&apos;&lt;span&gt;&apos;+name+&apos;&lt;/span&gt;&apos;+&apos;:&apos;+msg);
});
</code></pre></li>
</ol>
<h4 id="最终测试效果如下："><a href="#最终测试效果如下：" class="headerlink" title="最终测试效果如下："></a>最终测试效果如下：</h4><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/user1.png" alt="user1"><br><img src="http://7xsi10.com1.z0.glb.clouddn.com/user2.png" alt="user2"><br><img src="http://7xsi10.com1.z0.glb.clouddn.com/user3.png" alt="user3"></p>
<p>正如截图中的旁白君所说，应用还有bug和需要改善的地方，所以这篇文章会继续更新！<br>有兴趣的，可以到我的github查看应用全部源码:<br><a href="https://github.com/laoqiren/socket.io-demo" target="_blank" rel="external">我的github</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AJAX和Nodejs实现跨域]]></title>
      <url>http://yoursite.com/2016/05/19/AJAX%E5%92%8CNodejs%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h3 id="由于出于安全方面的考虑，JavaScript有着跨源策略的限制，也就是某个域的网页只能对同域进行访问。本文记录几种跨域实现及我自己的实践。"><a href="#由于出于安全方面的考虑，JavaScript有着跨源策略的限制，也就是某个域的网页只能对同域进行访问。本文记录几种跨域实现及我自己的实践。" class="headerlink" title="由于出于安全方面的考虑，JavaScript有着跨源策略的限制，也就是某个域的网页只能对同域进行访问。本文记录几种跨域实现及我自己的实践。"></a>由于出于安全方面的考虑，JavaScript有着跨源策略的限制，也就是某个域的网页只能对同域进行访问。本文记录几种跨域实现及我自己的实践。</h3><a id="more"></a>
<h3 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h3><p>所谓代理，就是用后台技术实现代理服务器，前端访问代理服务器，代理服务器向实际服务器发起请求，拿到数据再返回给前端。 例如一个网站有两个服务器www.Chongqing.com和www.Hangzhou.com，在杭州的话想访问重庆服务器的资源，先直接访问杭州服务器，杭州服务器再从重庆服务器拉取数据最后返回给杭州的user-agent.</p>
<h3 id="2-图像ping"><a href="#2-图像ping" class="headerlink" title="2. 图像ping"></a>2. 图像ping</h3><h4 id="虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如-img-iframe-script-，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。"><a href="#虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如-img-iframe-script-，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。" class="headerlink" title="虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如 img,iframe,script  ，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。"></a>虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如 img,iframe,script  ，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。</h4><p>图像ping用于客户端和服务端进行单向的简单的通信,只能发送get请求，无法访问服务器响应文本，在这里不详解；</p>
<h3 id="3-iframe及HTML5跨文档消息传递-XDM"><a href="#3-iframe及HTML5跨文档消息传递-XDM" class="headerlink" title="3. iframe及HTML5跨文档消息传递(XDM)"></a>3. iframe及HTML5跨文档消息传递(XDM)</h3><h4 id="详细内容下篇文章补充"><a href="#详细内容下篇文章补充" class="headerlink" title="详细内容下篇文章补充"></a>详细内容下篇文章补充</h4><h3 id="4-JSONP"><a href="#4-JSONP" class="headerlink" title="4. JSONP"></a>4. JSONP</h3><h4 id="啥是JSONP-JSON-with-padding（参数式json-，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下："><a href="#啥是JSONP-JSON-with-padding（参数式json-，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下：" class="headerlink" title="啥是JSONP? JSON with padding（参数式json)，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下："></a>啥是JSONP? JSON with padding（参数式json)，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下：</h4><pre><code>&lt;script src=&apos;www.luoxia520.com/blog/?callback=callback&apos;&gt;&lt;/script&gt;
&lt;script&gt;
    function callback(data){
        console.log(data.name);
    }
&lt;/script&gt;
</code></pre><p>这里通过script可加载任意域内容的特点对异域进行强求，查询字符串包含callback参数，服务器传回的是可执行的js代码，即对于的callback(data)调用。当然服务端代码也要响应的更改。下面介绍。</p>
<h3 id="这里以jquery的ajax为例"><a href="#这里以jquery的ajax为例" class="headerlink" title="这里以jquery的ajax为例:"></a>这里以jquery的ajax为例:</h3><ol>
<li><p>前端ajax请求代码: testJsonp.html</p>
<pre><code>$(function(){
        $.ajax({
            dataType: &apos;jsonp&apos;,
            url: &apos;http://localhost:8088&apos;,
            type:&apos;get&apos;,
            success: function(data){
                   $(&apos;#name&apos;).text(data);
            }
        });
 });
</code></pre></li>
<li><p>用Nodejs实现得异域服务器代码:</p>
<pre><code>var http = require(&apos;http&apos;);
var urlLib = require(&apos;url&apos;);
var data = {name:&apos;luoxia&apos;,year:18};
http.createServer(function(req,res){
    var parms = urlLib.parse(req.url,true);
    var str = parms.query.callback + &apos;(&apos; + JSON.stringify(data) +&apos;)&apos;;
    res.end(str);
}).listen(8088);
</code></pre></li>
</ol>
<p>jquery的ajax也是利用script的原理，只不过只要设置了dataType为jsonp的话，就自动回发送jsonp请求，我们可以看到testJsonp.html请求的URL:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/jsonp.png" alt="jsonp"><br>看到了吧，自动加上了callback查询字符串，callback的值是动态生成的，当然也可以指定其值，没啥影响，还有，前面的callback这个，也可以改的，通过jsonp属性指定，当然这是细节。</p>
<p>nodejs通过查询callback值，即回调函数名，然后返回传递了json数据的可执行js字符串。</p>
<p>最后成功地实现了跨域，哈哈哈哈哈哈哈哈。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/luoxia.png" alt="luoxia"></p>
<h5 id="jsonp只能发送get请求。"><a href="#jsonp只能发送get请求。" class="headerlink" title="jsonp只能发送get请求。"></a>jsonp只能发送get请求。</h5><p>当然这里开始遇到了个问题，console老是报错</p>
<pre><code>Failed to load resource: net::ERR_CACHE_MISS
</code></pre><p>，好大一半天不知道咋解决，后面在论坛的悠悠建议下，给ajax请求url加了个协议，丫的，成了。。。或许无法自动补全吧，细节啊。。。。</p>
<h3 id="5-CORS"><a href="#5-CORS" class="headerlink" title="5. CORS"></a>5. CORS</h3><h5 id="CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。"><a href="#CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。" class="headerlink" title="CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。"></a>CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。</h5><ol>
<li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</p>
</li>
<li><p>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>
</li>
<li><p>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS</p>
</li>
</ol>
<p>要求请求头加入</p>
<pre><code>Origin: host:port
</code></pre><p>响应头必须加入和请求头同样host:port的响应信息:</p>
<pre><code>Access-Control-Allow-Origin: host:port
</code></pre><p>IE8以下的就别想了,IE8，IE9可以通过XDR实现，反正我觉得，垃圾IE,现在微软自己都放弃治疗了。。。。。。</p>
<p>来具体看看实现例子，还是jquery的ajax:</p>
<p>前端testCORS.html:</p>
<pre><code>$(function(){
        $.ajax({
            url: &apos;http://localhost:8088&apos;,
            type:&apos;get&apos;,
            success: function(data){
                   $(&apos;#name&apos;).text(JSON.parse(data).name);
            }
        });
 });
</code></pre><p>Node： CORS.js</p>
<pre><code>var http = require(&apos;http&apos;);
//var urlLib = require(&apos;url&apos;);
var data = {name:&apos;luoxia&apos;,year:18};
http.createServer(function(req,res){
    var parms = urlLib.parse(req.url,true);
    res.writeHead(200,{&apos;Access-Control-Allow-Origin&apos;:&apos;*&apos;,&apos;Access-Control-Allow-Method&apos;:&apos;GET,POST&apos;});
    res.end(JSON.stringify(data));
}).listen(8088);
</code></pre><p>这里Access-Control-Allow-Origin可以设置为*代表允许说有域，当然也可以写具体的url。<br>最终是没问题的：</p>
<p>CORS一定程度上缓解了CSRF,XSS等安全问题。</p>
<p>明天就5.20，国际计量节！单身狗过国际计量节，new对象去了。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端模块化]]></title>
      <url>http://yoursite.com/2016/05/07/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="AMD实现者之前端模块化工具requirejs"><a href="#AMD实现者之前端模块化工具requirejs" class="headerlink" title="AMD实现者之前端模块化工具requirejs"></a>AMD实现者之前端模块化工具requirejs</h1><h3 id="本文记录requirejs的模块路径问题"><a href="#本文记录requirejs的模块路径问题" class="headerlink" title="本文记录requirejs的模块路径问题"></a>本文记录requirejs的模块路径问题</h3><a id="more"></a>
<h5 id="在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS-AMD-UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）"><a href="#在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS-AMD-UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）" class="headerlink" title="在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS,AMD,UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）"></a>在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS,AMD,UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）</h5><p>我的项目结构（测试用，不合理）：</p>
<pre><code>----gulp
    ----app
        ----html
                index.html
        ----js
                a.js
                b.js
                c.js
        ----require.js
        ----config.js
    ----bower_comonents
        ----jquery
            ----dist
                jquery.min.js
</code></pre><ol>
<li><p>当引入requirejs的时候指定data-main属性:(index.html)</p>
<pre><code>&lt;script data-main=&quot;../config&quot; src=&quot;../require.js&quot;&gt;&lt;/script&gt;
</code></pre></li>
<li><p>data-main作为入口文件，有个作用就是它会把模块的baseUrl设置为config所在目录</p>
</li>
<li><p>然后配置config.js:</p>
<pre><code>require.config({
    paths : {
        jquery: [&apos;../bower_components/jquery/dist/jquery.min&apos;]
    }
});
</code></pre></li>
<li><p>baseUrl就是config文件所在目录，设定paths值当然根据baseUrl来，如这里就相当于gulp/app/../bower_components/jquery/dist/jquery.min，然后index.html:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    require([&apos;jquery&apos;],function($){
        $(&apos;body&apos;).append($(&apos;&lt;p&gt;hello&lt;/p&gt;&apos;));
    })
&lt;/script&gt;
</code></pre><p>理论上是没问题的，但会报错，get app/jquery.js net::ERR_FILE_NOT_FOUND，这咋回事？paths根本没生效，然后我又试着显示地配置baseUrl属性（注意配置路径是针对于引入requirejs的那个html文件来的），照样报同样的错误，最后，我这样写：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../require.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../config.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    require([&apos;jquery&apos;],function($){
        $(&apos;body&apos;).append($(&apos;&lt;p&gt;hello&lt;/p&gt;&apos;));
    })
&lt;/script&gt;
</code></pre></li>
</ol>
<p>也就是说，config分开加载，当然此时的config配置会有所变化，因为不是在data-main属性中引入，所有baseUrl默认的会是这里引入require的html文件的路径，所以：</p>
<pre><code>require.config({
    baseUrl:&apos;../../&apos;,
    paths : {
        jquery: [&apos;bower_components/jquery/dist/jquery.min&apos;]
    }
});
</code></pre><p>这里baseUrl设置后就相当于gulp目录，然后现在在运行html,达到预期效果，why?</p>
<h4 id="应该是这样：开始的例子中，引入require文件，加载执行require-js-然后异步加载config-js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app-js-jquery-js，没找到，所以挂了。"><a href="#应该是这样：开始的例子中，引入require文件，加载执行require-js-然后异步加载config-js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app-js-jquery-js，没找到，所以挂了。" class="headerlink" title="应该是这样：开始的例子中，引入require文件，加载执行require.js,然后异步加载config.js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app/js/jquery.js，没找到，所以挂了。"></a>应该是这样：开始的例子中，引入require文件，加载执行require.js,然后异步加载config.js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app/js/jquery.js，没找到，所以挂了。</h4><p>我的解决办法：<br>要么把代码放在config.js中，要么在config里引入我的代码模块,或者同步加载config配置，只不过是baseUrl不同而已。</p>
<h4 id="另外还有一个需要注意到的是，在定义模块的时候，define-id-dep-factory-的时候，dep依赖其他模块的目录有两种方式："><a href="#另外还有一个需要注意到的是，在定义模块的时候，define-id-dep-factory-的时候，dep依赖其他模块的目录有两种方式：" class="headerlink" title="另外还有一个需要注意到的是，在定义模块的时候，define(id,dep,factory)的时候，dep依赖其他模块的目录有两种方式："></a>另外还有一个需要注意到的是，在定义模块的时候，define(id,dep,factory)的时候，dep依赖其他模块的目录有两种方式：</h4><ol>
<li>依据config显式地设置的baseUrl或者默认的baseUrl的路径结合paths配置</li>
<li>./开头的路径，那么久不是根据baseUrl了，是根据这个模块本身的位置来的</li>
</ol>
<p>举个栗子：</p>
<p>index.html:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../require.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../config.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/a.js&quot;&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    require([&apos;jquery&apos;],function($){
        $(&apos;body&apos;).append($(&apos;&lt;p&gt;hello&lt;/p&gt;&apos;));
    })
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;hello wrold&lt;/div&gt;
&lt;/body&gt;
</code></pre><p>config.js:</p>
<pre><code>require.config({
    baseUrl:&apos;../../&apos;,
    paths : {
        jquery: [&apos;bower_components/jquery/dist/jquery.min&apos;]
    }
});
</code></pre><p>a.js:</p>
<pre><code>require([&apos;app/js/b&apos;],function(b){
    b.jq();
});
</code></pre><p>b.js:</p>
<pre><code>//这里也可以define([&apos;jquery&apos;,&apos;./c&apos;],...)
define([&apos;jquery&apos;,&apos;app/js/c&apos;],function($,c){
    var b = {};
    b.jq = function(){
        $(&apos;body&apos;).append($(&apos;&lt;p&gt;hello&lt;/p&gt;&apos;));
    };
    console.log(c.name);
    return b;
});
</code></pre><p>c.js:</p>
<pre><code>define(function(){
    return {
        name:&apos;luoxia&apos;
    };
});
</code></pre><p>b模块依赖c模块的情况说明这个问题，然后require是一定根据baseUrl来的</p>
<h4 id="es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD-CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。"><a href="#es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD-CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。" class="headerlink" title="es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD,CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。"></a>es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD,CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gulp前端自动化]]></title>
      <url>http://yoursite.com/2016/04/26/gulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="gulp前端自动化配置"><a href="#gulp前端自动化配置" class="headerlink" title="gulp前端自动化配置"></a>gulp前端自动化配置</h1><h3 id="使用gulp提高前端开发效率"><a href="#使用gulp提高前端开发效率" class="headerlink" title="使用gulp提高前端开发效率"></a>使用gulp提高前端开发效率</h3><a id="more"></a>
<h4 id="gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。"><a href="#gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。" class="headerlink" title="gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。"></a>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</h4><p>分享我在使用过程中的心得</p>
<p>使用gulp：</p>
<ol>
<li><p>全局安装gulp：</p>
<pre><code>npm install -g gulp
</code></pre></li>
<li><p>初始化项目，package.json可以帮助我们管理依赖，一个node package有两种依赖，一种是dependencies一种是devDependencies，其中前者依赖的项该是正常运行该包时所需要的依赖项，而后者则是开发的时候需要的依赖项，像一些进行单元测试之类的包。</p>
<pre><code>npm init
</code></pre></li>
<li><p>局部安装gulp:</p>
<pre><code>npm install --save-dev gulp
</code></pre></li>
<li><p>安装依赖插件:</p>
<pre><code>npm install --save-dev gulp-ruby-sass
</code></pre></li>
<li><p>我的配置:</p>
</li>
</ol>
<pre><code>&apos;use strict&apos;;

//引入依赖模块
var gulp = require(&apos;gulp&apos;),
   uglify = require(&apos;gulp-uglify&apos;),
   babel = require(&apos;gulp-babel&apos;),
   watch = require(&apos;gulp-watch&apos;),
   sass = require(&apos;gulp-ruby-sass&apos;),
   autoprefix = require(&apos;gulp-autoprefixer&apos;),
   rename = require(&apos;gulp-rename&apos;),
   concat = require(&apos;gulp-concat&apos;),
   browserSync = require(&apos;browser-sync&apos;);

//编译sass到css
gulp.task(&apos;sass&apos;, function () {
  return sass(&apos;app/sass/*.scss&apos;)
    .on(&apos;error&apos;, sass.logError)
    .pipe(gulp.dest(&apos;build/css/&apos;));
});

//合并多个js文件,压缩，并重命名
gulp.task(&apos;concat&apos;, function () {
    gulp.src(&apos;build/js/*.js&apos;)
        .pipe(concat(&apos;all.js&apos;))
        .pipe(uglify())
        .pipe(rename(&apos;all.min.js&apos;))
        .pipe(gulp.dest(&apos;dist/js&apos;));
});

// 自动补全css3浏览器兼容前缀
gulp.task(&apos;styles&apos;, function() {
  gulp.src([&apos;./build/css/test.css&apos;])
    .pipe(autoprefix(&apos;last 2 versions&apos;))
    .pipe(gulp.dest(&apos;./dist/css&apos;));
});

//babel转换es2015到es5
gulp.task(&apos;babel&apos;,function(){
   return gulp.src(&quot;app/js/*.js&quot;)// ES6 源码存放的路径
    .pipe(babel({presets: [&apos;es2015&apos;]}))
    .pipe(gulp.dest(&quot;build/js&quot;)); //转换成 ES5 存放的路径
   });

//监控es2015文件，sass文件，自动编译为es5文件，css文件
gulp.task(&apos;watch&apos;, function () {
   gulp.watch([&apos;app/js/es2015.js&apos;,&apos;app/sass/*.scss&apos;], [&apos;babel&apos;,&apos;sass&apos;]);
});

//浏览器实时自动更新状态，不用手动刷新
gulp.task(&apos;browser-sync&apos;, function () {
   var files = [
      &apos;app/**/*&apos;
   ];
   browserSync.init(files, {
      server: {
         baseDir: [&apos;./app/html&apos;,&apos;./app/&apos;]
      }
   });
});
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js模板引擎初体验之jade]]></title>
      <url>http://yoursite.com/2016/04/22/js%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8Bjade/</url>
      <content type="html"><![CDATA[<h1 id="从jade初探js模板引擎思想"><a href="#从jade初探js模板引擎思想" class="headerlink" title="从jade初探js模板引擎思想 "></a>从jade初探js模板引擎思想 <a id="more"></a></h1><h3 id="因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率"><a href="#因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率" class="headerlink" title="因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率"></a>因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率</h3><h4 id="这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面"><a href="#这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面" class="headerlink" title="这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面"></a>这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面</h4><p>之前的项目中，我是这么干的：通过ajax获取服务器返回的json数据,然后通过拼接字符串的形式来生成dom，再插入到页面。</p>
<p>jade在html元素内容中引入变量</p>
<pre><code>p #{content}  //content变量表示文章内容
</code></pre><p>通过each循环变量数组或对象</p>
<pre><code>- var array = [&apos;jack&apos;,&apos;jane&apos;,&apos;marry&apos;]
- var obj = {name:&apos;luoxia&apos;,girlfriend:&apos;null&apos;}
ul
    each item in array
        li item

each key,value in obj
    p #{key}:#{value}
</code></pre><p>输出结果”:</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;jack&lt;/li&gt;
    &lt;li&gt;jane&lt;/li&gt;
    &lt;li&gt;marry&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;name:luoxia&lt;/p&gt;
&lt;p&gt;girlfriend:null&lt;/p&gt;
</code></pre><p>现在加入要从服务器获取某个表格内容，而这个表格的内容是不断变化的，而且表格项数不确定，我们可以通过ajax获取一个包含表格内容的json对象（这里运用bootstrap框架)</p>
<pre><code>//backData:
{
    sections:[{class:&apos;active&apos;,name:&apos;罗峡&apos;,addr:&apos;中国重庆&apos;},{class:&apos;info&apos;,name:&apos;小明&apos;,addr:&apos;火星&apos;},
        {class:&apos;warning&apos;,name:&apos;大明&apos;,addr:&apos;遥远的地方&apos;}]
};
</code></pre><p>书写jade模板</p>
<pre><code>//table.jade
table(class=&apos;table table-bordered table-hover&apos;)
thead
    tr
        td 姓名
        td 地址
tbody
    each section in sections
        tr(class=&apos;#{section.class}&apos;)
            td #{section.name}
            td #{section.addr}
</code></pre><p>编译成模板js脚本</p>
<pre><code>$ jade --client --no-debug table.jade
rendered table.js
</code></pre><p>在页面中引入jade的runtimejs文件和table.js文件,最后通过将json传递给table.js暴露出的方法</p>
<pre><code>var addHtml = template(backData);
document.body.innerHTML = addHtml;
</code></pre><p>这样，动态生成格式类似的代码块就完成了。一个漂亮的表格:<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/table.png" alt="table"></p>
<p>在es2015语法中新增了一种叫做模板字符串的字符串字面量，模板字符串以反引号代替一般字符串的引号和双引号，变量或者表达式通过占位符${}语法来引入。但模板字符串本身不支持条件或循环等模板引擎类似的语法:</p>
<pre><code>ul
    for (var k in lis)
        li= lis[k]
</code></pre><p>嗯，但是es2015里有个东西叫做标签模板的东西，什么叫标签模板呢，就是一个标签（实际上是一个函数）后跟上模板字符串，而这个模板字符串会被作为参数传入前面的标签函数，第一个参数是未被占位符替换的部分组成的数组，而后面的参数都是各个变量，我们可以通过标签模板自定义功能：</p>
<pre><code>let lis = [&apos;luoxia is good&apos;,&apos;luoxia is very good&apos;,&apos;luoxia can\&apos;t be more good&apos;];
function addLis(s,...array){
    let string = &apos;&apos;;
    string += s[0];
    for(let i=0; i&lt;array[0].length;i++){
        string +=
        `
        &lt;li&gt;
            ${array[0][i]}
        &lt;/li&gt;`;
    }
    string += s[1];
    return string;
}
console.log(addLis `&lt;ul&gt;
            ${lis}&lt;/ul&gt;`);
    /*
            $ node es2015.js
&lt;ul&gt;

        &lt;li&gt;
            luoxia is good
        &lt;/li&gt;
        &lt;li&gt;
            luoxia is very good
        &lt;/li&gt;
        &lt;li&gt;
            luoxia can&apos;t be more good
        &lt;/li&gt;&lt;/ul&gt;
    */
</code></pre><p>不过略显麻烦啊感觉有木有（或许是我实现得麻烦）</p>
<p>前端技术瞬息万变，模板引擎的时代或许早已过去，但是我们可以在学习中去体会它的思想，发现它的不足，在对比中成长，然后在实践中找到更适合具体场景的技术，不在追逐中迷失自我，而是让自己的心智，能力得到成长。（菜鸟的自白，不喜勿喷）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nodejs刷百度贴吧回复]]></title>
      <url>http://yoursite.com/2016/04/21/nodejs%E5%88%B7%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%9B%9E%E5%A4%8D/</url>
      <content type="html"><![CDATA[<h1 id="nodejs尝试之刷百度贴吧回复"><a href="#nodejs尝试之刷百度贴吧回复" class="headerlink" title="nodejs尝试之刷百度贴吧回复 "></a>nodejs尝试之刷百度贴吧回复 <a id="more"></a></h1><h3 id="作为前端必备技能的nodejs-非常有趣"><a href="#作为前端必备技能的nodejs-非常有趣" class="headerlink" title="作为前端必备技能的nodejs,非常有趣"></a>作为前端必备技能的nodejs,非常有趣</h3><h4 id="利用NodeJs的http模块，很简单地就能做一个刷回复的脚本"><a href="#利用NodeJs的http模块，很简单地就能做一个刷回复的脚本" class="headerlink" title="利用NodeJs的http模块，很简单地就能做一个刷回复的脚本"></a>利用NodeJs的http模块，很简单地就能做一个刷回复的脚本</h4><p>这次借用高考吧一学妹的帖子来刷一刷，哈哈，邪恶邪恶<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua1.png" alt="tie"><br>nodejs提供的http模块，我们需要用http模块的request方法想服务端发送请求来发送/接收信息</p>
<ol>
<li><p>require进两个模块</p>
<p> var http = require(‘http’);<br> var querystring = require(‘querystring’);</p>
</li>
<li><p>request方法返回一个http.ClientRequest的实例，如果用POST方法向服务端发送数据，数据对象会被写入该对象，request方法接受两个参数，一个必须的options参数，一个可选的callback函数，callback函数可以接受到来自服务端的响应作为参数，options参数可以为字符串或者对象，字符串会被url模块的parse方法序列化为对象</p>
</li>
<li>打开学妹的帖子，我们编辑一条回复信息，然后查看网络面板，查看add的ajax请求信息<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua2.png" alt="add"></li>
<li>options参数的header属性值为请求头信息，当然得是Json对象</li>
<li>注意Content-Length要设置为postData.length，不然可能请求失败</li>
<li>在最开始的时候，老是出现如下错误:<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua3.png" alt="error"><br>最后查阅错误代码，stackoverflow上的解决办法是不加http/https协议，果然，成功<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua4.png" alt="success"></li>
<li>然后，邪恶的加个定时器，一直刷，看结果<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/many.png" alt="many"><br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua6.png" alt="many"></li>
<li>很好玩吧，不过多次刷会出现验证码的，哎，刚学，知识技能不熟悉，只能写个简单的yy一下了，不过这测验也能看出百度的安全并不是那么好，哈哈</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ruby-sass-problem]]></title>
      <url>http://yoursite.com/2016/04/10/ruby-sass-problem/</url>
      <content type="html"><![CDATA[<h1 id="关于windows下通过ruby安装sass和compass的问题"><a href="#关于windows下通过ruby安装sass和compass的问题" class="headerlink" title="关于windows下通过ruby安装sass和compass的问题"></a>关于windows下通过ruby安装sass和compass的问题</h1><h3 id="安装sass和compass"><a href="#安装sass和compass" class="headerlink" title="安装sass和compass"></a>安装sass和compass</h3><a id="more"></a>
<p>执行 gem sources -a <a href="https://ruby.taobao.org/出现如下错误" target="_blank" rel="external">https://ruby.taobao.org/出现如下错误</a><br><img src="http://7xsi10.com2.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160410233014.png" alt="error"><br>缺少SSL证书</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol>
<li>下载证书：<a href="https://curl.haxx.se/ca/cacert.pem" target="_blank" rel="external">官方地址</a>　<a href="http://pan.baidu.com/s/1pKJSlOf" target="_blank" rel="external">百度云盘</a></li>
<li>将证书保存，比如我的保存到了C:\Ruby22-x64。</li>
<li>配置证书的环境<img src="http://7xsi10.com2.z0.glb.clouddn.com/870258-20160405180306187-1063124604.png" alt="path"></li>
<li>重启，再执行，当当当当，哈哈，成功了<img src="http://7xsi10.com2.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160410233111.png" alt="succed"><h5 id="感谢angular社区前辈-会飞的鱼lala-提供的方法"><a href="#感谢angular社区前辈-会飞的鱼lala-提供的方法" class="headerlink" title="感谢angular社区前辈 会飞的鱼lala 提供的方法"></a>感谢angular社区前辈 会飞的鱼lala 提供的方法</h5></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[front end technology]]></title>
      <url>http://yoursite.com/2016/03/14/front-end-technology/</url>
      <content type="html"><![CDATA[<h2 id="2015-2016-前端技能体系图"><a href="#2015-2016-前端技能体系图" class="headerlink" title="2015-2016 前端技能体系图"></a>2015-2016 前端技能体系图</h2><h3 id="转自ouvens的github"><a href="#转自ouvens的github" class="headerlink" title="转自ouvens的github"></a>转自ouvens的github</h3><h4 id="茫茫前端大海，学海无涯，苦作舟"><a href="#茫茫前端大海，学海无涯，苦作舟" class="headerlink" title="茫茫前端大海，学海无涯，苦作舟  "></a>茫茫前端大海，学海无涯，苦作舟  <a id="more"></a></h4><p><img src="http://static.open-open.com/news/uploadImg/20160126/20160126133319_831.png" alt="前端知识体系图"></p>
<h2 id="一、框架与组件"><a href="#一、框架与组件" class="headerlink" title="一、框架与组件"></a>一、框架与组件</h2><h3 id="bootstrap等UI框架设计与实现"><a href="#bootstrap等UI框架设计与实现" class="headerlink" title="bootstrap等UI框架设计与实现"></a>bootstrap等UI框架设计与实现</h3><ul>
<li><p>伸缩布局：grid网格布局</p>
</li>
<li><p>基础UI样式：元素reset、按钮、图片、菜单、表单</p>
</li>
<li><p>组件UI样式：按钮组、字体图标、下拉菜单、输入框组、导航组、面包屑、分页、标签、轮播、弹出框、列表、多媒体、警告</p>
</li>
<li><p>响应式布局：布局、结构、样式、媒体、javascript响应式</p>
</li>
<li><p>第三方插件：插件管理</p>
</li>
</ul>
<h3 id="jQuery、zepto使用原理以及插件开发"><a href="#jQuery、zepto使用原理以及插件开发" class="headerlink" title="jQuery、zepto使用原理以及插件开发"></a>jQuery、zepto使用原理以及插件开发</h3><ul>
<li><p>支持amd、cmd、全局变量的模块化封装</p>
</li>
<li><p>$.fn.method = function(){}</p>
</li>
</ul>
<h3 id="mvc-mvvm框架原理设计，vue-angular-avalon等"><a href="#mvc-mvvm框架原理设计，vue-angular-avalon等" class="headerlink" title="mvc/mvvm框架原理设计，vue/angular/avalon等"></a>mvc/mvvm框架原理设计，vue/angular/avalon等</h3><ul>
<li><p>directive设计：html、text、class、html、attr、repeat、ref，可扩展</p>
</li>
<li><p>filter设计：bool、upperCase、lowerCase，可扩展</p>
</li>
<li><p>表达式设计：if-else等实现</p>
</li>
<li><p>viewmodel结构设计：例如数据，元素，方法的挂载与作用域</p>
</li>
<li><p>数据更变检测：函数触发，脏数据检测、对象hijacking</p>
</li>
</ul>
<h3 id="polymer-angular2思想与设计思路"><a href="#polymer-angular2思想与设计思路" class="headerlink" title="polymer/angular2思想与设计思路"></a>polymer/angular2思想与设计思路</h3><ul>
<li><p>import技术</p>
</li>
<li><p>template和script引入方式</p>
</li>
<li><p>css样式命名空间隔离</p>
</li>
<li><p>简单复用第三方库</p>
</li>
</ul>
<h3 id="reactjs原理与使用"><a href="#reactjs原理与使用" class="headerlink" title="reactjs原理与使用"></a>reactjs原理与使用</h3><ul>
<li><p>virtual dom单向数据绑定</p>
</li>
<li><p>js执行语法方式</p>
</li>
<li><p>UI由状态控制</p>
</li>
</ul>
<h3 id="commonJS-AMD-CMD"><a href="#commonJS-AMD-CMD" class="headerlink" title="commonJS/AMD/CMD"></a>commonJS/AMD/CMD</h3><ul>
<li><p>模块引入</p>
</li>
<li><p>模块定义</p>
</li>
<li><p>模块标识</p>
</li>
<li><p>UMD解决不同规范兼容性的问题，例如webpack封装</p>
</li>
<li><p>模块懒执行(CMD)与与预执行(AMD)</p>
</li>
</ul>
<h3 id="loadJs模块化加载原理与实现"><a href="#loadJs模块化加载原理与实现" class="headerlink" title="loadJs模块化加载原理与实现"></a>loadJs模块化加载原理与实现</h3><ul>
<li><p>创建script标签，需要id映射到资源url</p>
</li>
<li><p>onload加载模块队列判断</p>
</li>
<li><p>全部加载完成后触发</p>
</li>
<li><p>加载失败问题优化</p>
</li>
<li><p>requirejs、modjs、seajs</p>
</li>
</ul>
<h3 id="polyfill、shim原理与实现"><a href="#polyfill、shim原理与实现" class="headerlink" title="polyfill、shim原理与实现"></a>polyfill、shim原理与实现</h3><ul>
<li><p>polyfill提供了开发者们希望浏览器原生提供支持的功能特性</p>
</li>
<li><p>shim将新的API引入到旧的环境中,且仅靠旧环境中已有的手段实现</p>
</li>
</ul>
<h3 id="virtual-Dom、Incremental-DOM"><a href="#virtual-Dom、Incremental-DOM" class="headerlink" title="virtual Dom、Incremental DOM"></a>virtual Dom、Incremental DOM</h3><ul>
<li><p>1.用js对象树表示dom树结构，根据该对象树构建dom树</p>
</li>
<li><p>2.状态改变时，重新构建对象，和旧的对象对比，记录两个对象树差异</p>
</li>
<li><p>3.将对象树差异应用到dom中</p>
</li>
<li><p>小结:js对象模拟dom(elem.js)，virtual dom diff算法(diff.js)、差异渲染dom(patch.js)</p>
</li>
<li><p>incremental dom在状态改变时扫描旧对象树将差异直接应用到dom中</p>
</li>
</ul>
<h3 id="shadow-dom"><a href="#shadow-dom" class="headerlink" title="shadow dom"></a>shadow dom</h3><ul>
<li><p>隔离外部环境用于封装组件：结构、样式、行为</p>
</li>
<li><p>实现形式：新标签、class类属性 + 构建编译</p>
</li>
</ul>
<h3 id="webwork与service-Worker"><a href="#webwork与service-Worker" class="headerlink" title="webwork与service Worker"></a>webwork与service Worker</h3><ul>
<li><p>webwork与主线程机制，on/post</p>
</li>
<li><p>serviceworker可作为浏览器请求代理</p>
</li>
<li><p>应用场景</p>
</li>
</ul>
<h3 id="ES6转ES5、Babel与ES6开发规范体系"><a href="#ES6转ES5、Babel与ES6开发规范体系" class="headerlink" title="ES6转ES5、Babel与ES6开发规范体系"></a>ES6转ES5、Babel与ES6开发规范体系</h3><ul>
<li><p>ES6编码规范全</p>
</li>
<li><p>ES6在babel下兼容性</p>
</li>
<li><p>ES6在node下兼容性与性能</p>
</li>
<li><p>ES6新特性：看编码规范</p>
</li>
<li><p>aurelia ES6前端框架</p>
</li>
</ul>
<h3 id="Isomorphic-JavaScript"><a href="#Isomorphic-JavaScript" class="headerlink" title="Isomorphic JavaScript"></a>Isomorphic JavaScript</h3><ul>
<li><p>同构原理</p>
</li>
<li><p>同构方案 Rendr</p>
</li>
<li><p>nodejs: 服务器</p>
</li>
<li><p>hapi: 应用服务</p>
</li>
<li><p>backbone.js: 后台mvc</p>
</li>
<li><p>requirejs: 模块加载</p>
</li>
<li><p>jquery: dom处理</p>
</li>
<li><p>reactjs同构:React + Flux + Koa</p>
</li>
</ul>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><ul>
<li><p>函数触发:vuejs</p>
</li>
<li><p>脏数据检测:angular</p>
</li>
<li><p>对象hijacking:avalon</p>
</li>
</ul>
<h3 id="browserify运行原理"><a href="#browserify运行原理" class="headerlink" title="browserify运行原理"></a>browserify运行原理</h3><ul>
<li><p>1.从入口模块开始分析require函数调用</p>
</li>
<li><p>2.根据依赖生成AST</p>
</li>
<li><p>3.根据AST找到每个模块的模块名</p>
</li>
<li><p>4.得到每个模块的依赖关系，生成一个依赖字典</p>
</li>
<li><p>5.包装每个模块（传入依赖字典以及export和require函数），生成执行的js</p>
</li>
</ul>
<h3 id="performance-timing"><a href="#performance-timing" class="headerlink" title="performance timing"></a>performance timing</h3><ul>
<li><p>performance timing api</p>
</li>
<li><p>performance timing 过程</p>
</li>
<li><p>performance timing 性能计算</p>
</li>
<li><p>performanceTrace库</p>
</li>
</ul>
<h3 id="组件UI与js组件规范化"><a href="#组件UI与js组件规范化" class="headerlink" title="组件UI与js组件规范化"></a>组件UI与js组件规范化</h3><ul>
<li><p>组件编码规范</p>
</li>
<li><p>组件目录规范：组件目录与公用目录</p>
</li>
<li><p>组件构建规范：构建环境支持</p>
</li>
<li><p>组件模块化管理：spm，bowserify</p>
</li>
<li><p>组件复用性管理</p>
</li>
<li><p>第三方组件接入成本</p>
</li>
</ul>
<h3 id="immutable-JavaScript"><a href="#immutable-JavaScript" class="headerlink" title="immutable JavaScript"></a>immutable JavaScript</h3><h3 id="generator与promise原理与使用"><a href="#generator与promise原理与使用" class="headerlink" title="generator与promise原理与使用"></a>generator与promise原理与使用</h3><h2 id="二、构建生态"><a href="#二、构建生态" class="headerlink" title="二、构建生态"></a>二、构建生态</h2><h3 id="grunt-gulp开发环境任务编写"><a href="#grunt-gulp开发环境任务编写" class="headerlink" title="grunt/gulp开发环境任务编写"></a>grunt/gulp开发环境任务编写</h3><ul>
<li><p>文件处理插件：html、scss、js、image、font、其它</p>
</li>
<li><p>优化插件：雪碧图、图片压缩、iconfont构建</p>
</li>
<li><p>发布替换插件</p>
</li>
<li><p>打包、压缩包插件：组件自动分析</p>
</li>
<li><p>白名单配置</p>
</li>
<li><p>自定义插件编写</p>
</li>
</ul>
<h3 id="npm、jspm、bower包管理工具"><a href="#npm、jspm、bower包管理工具" class="headerlink" title="npm、jspm、bower包管理工具"></a>npm、jspm、bower包管理工具</h3><h3 id="r-js、browserify、webpack、webpack-2、Rollup打包工具使用"><a href="#r-js、browserify、webpack、webpack-2、Rollup打包工具使用" class="headerlink" title="r.js、browserify、webpack、webpack 2、Rollup打包工具使用"></a>r.js、browserify、webpack、webpack 2、Rollup打包工具使用</h3><ul>
<li><p>原理：根据依赖配置文件对文件进行依赖打包</p>
</li>
<li><p>webpack支持更多的规范打包，AMD,Commonjs</p>
</li>
<li><p>webpack+babel/reactjs+reflux</p>
</li>
</ul>
<h3 id="fis3构建与插件开发、构建环境、fis3构建离线包"><a href="#fis3构建与插件开发、构建环境、fis3构建离线包" class="headerlink" title="fis3构建与插件开发、构建环境、fis3构建离线包"></a>fis3构建与插件开发、构建环境、fis3构建离线包</h3><h3 id="web-Component：rosetta-org、x-view、Q、riot、nova"><a href="#web-Component：rosetta-org、x-view、Q、riot、nova" class="headerlink" title="web Component：rosetta-org、x-view、Q、riot、nova"></a>web Component：rosetta-org、x-view、Q、riot、nova</h3><h3 id="brunch构建工具"><a href="#brunch构建工具" class="headerlink" title="brunch构建工具"></a>brunch构建工具</h3><h2 id="三、开发技巧与调试"><a href="#三、开发技巧与调试" class="headerlink" title="三、开发技巧与调试"></a>三、开发技巧与调试</h2><h3 id="fiddler加willow基础组合调试"><a href="#fiddler加willow基础组合调试" class="headerlink" title="fiddler加willow基础组合调试"></a>fiddler加willow基础组合调试</h3><ul>
<li><p>常见配置与分析</p>
</li>
<li><p>结合浏览器调试</p>
</li>
</ul>
<h3 id="werien、vorlonjs远程调试，chrome-inspect"><a href="#werien、vorlonjs远程调试，chrome-inspect" class="headerlink" title="werien、vorlonjs远程调试，chrome inspect"></a>werien、vorlonjs远程调试，chrome inspect</h3><h3 id="mockjs，F-M-S-Front-Mock-Server-模拟调试使用与cgi自动调试"><a href="#mockjs，F-M-S-Front-Mock-Server-模拟调试使用与cgi自动调试" class="headerlink" title="mockjs，F.M.S(Front Mock Server)模拟调试使用与cgi自动调试"></a>mockjs，F.M.S(Front Mock Server)模拟调试使用与cgi自动调试</h3><h3 id="macha-phantomjs-casperjs-karma测试自动化任务使用"><a href="#macha-phantomjs-casperjs-karma测试自动化任务使用" class="headerlink" title="macha/phantomjs/casperjs/karma测试自动化任务使用"></a>macha/phantomjs/casperjs/karma测试自动化任务使用</h3><h3 id="自动化UI测试，海豚"><a href="#自动化UI测试，海豚" class="headerlink" title="自动化UI测试，海豚"></a>自动化UI测试，海豚</h3><h3 id="node-supervior、node-inspector、karma"><a href="#node-supervior、node-inspector、karma" class="headerlink" title="node-supervior、node-inspector、karma"></a>node-supervior、node-inspector、karma</h3><h3 id="开发发布系统流程"><a href="#开发发布系统流程" class="headerlink" title="开发发布系统流程"></a>开发发布系统流程</h3><h3 id="sublime高效插件"><a href="#sublime高效插件" class="headerlink" title="sublime高效插件"></a>sublime高效插件</h3><ul>
<li>emmet工具使用、 sublimelinter、 babel snippets、 sublimeLint、 SassBeautify 、 emmet 快速编辑、 jsxlint、 SideBarEnhancements、 SnippetsMaker、 SublimeCodeIntel、 css snippets、 ColorPicker、 html/css/js Pretty、 SpinnetMacker、 DocBlockr、 MultiEditUtils、 javascript &amp; node spinnet、 JavaScript &amp; NodeJS Snippets、 jsLint、cssLint<h3 id="代码自动化检查fecs"><a href="#代码自动化检查fecs" class="headerlink" title="代码自动化检查fecs"></a>代码自动化检查fecs</h3></li>
</ul>
<h2 id="四、html、css与重构"><a href="#四、html、css与重构" class="headerlink" title="四、html、css与重构"></a>四、html、css与重构</h2><h3 id="jpeg、webp、apng、bpg图片"><a href="#jpeg、webp、apng、bpg图片" class="headerlink" title="jpeg、webp、apng、bpg图片"></a>jpeg、webp、apng、bpg图片</h3><ul>
<li><p>编码原理</p>
</li>
<li><p>特点与优劣势</p>
</li>
<li><p>适用场景</p>
</li>
</ul>
<h3 id="iconfont使用与实现原理"><a href="#iconfont使用与实现原理" class="headerlink" title="iconfont使用与实现原理"></a>iconfont使用与实现原理</h3><ul>
<li><p>自动打包构建方法</p>
</li>
<li><p>iconfont兼容性写法</p>
</li>
<li><p>fonthello、fontawesome、icomoon.io、iconfont.cn线上工具</p>
</li>
</ul>
<h3 id="页面响应式设计"><a href="#页面响应式设计" class="headerlink" title="页面响应式设计"></a>页面响应式设计</h3><ul>
<li><p>layout布局响应式</p>
</li>
<li><p>html结构响应式</p>
</li>
<li><p>css样式响应式</p>
</li>
<li><p>image媒体响应式</p>
</li>
<li><p>javascript响应式</p>
</li>
<li><p>media query与平台判断</p>
</li>
</ul>
<h3 id="css重置"><a href="#css重置" class="headerlink" title="css重置"></a>css重置</h3><ul>
<li><p>reset</p>
</li>
<li><p>nomalize</p>
</li>
<li><p>neat</p>
</li>
</ul>
<h3 id="sass-compass-less-postcss常用语法与使用"><a href="#sass-compass-less-postcss常用语法与使用" class="headerlink" title="sass/compass/less/postcss常用语法与使用"></a>sass/compass/less/postcss常用语法与使用</h3><ul>
<li><p>常用语法功能</p>
</li>
<li><p>组件化UI设计管理</p>
</li>
<li><p>构建工具实现方案</p>
</li>
<li><p>雪碧图自动合成</p>
</li>
<li><p>iconfont自动接入等等</p>
</li>
</ul>
<h3 id="media-query与常见页面尺寸了解"><a href="#media-query与常见页面尺寸了解" class="headerlink" title="media query与常见页面尺寸了解"></a>media query与常见页面尺寸了解</h3><ul>
<li><p>媒体类型引入和媒体特性引入</p>
</li>
<li><p>device-width适应</p>
</li>
<li><p>retina屏幕适应</p>
</li>
</ul>
<h3 id="em-rem原理与实现"><a href="#em-rem原理与实现" class="headerlink" title="em,rem原理与实现"></a>em,rem原理与实现</h3><ul>
<li><p>rem计算：width*retina/10，相当于屏幕宽度为10rem</p>
</li>
<li><p>字体在rem情况下仍然使用px</p>
</li>
</ul>
<h3 id="code4ui、code4app、初页、maka等"><a href="#code4ui、code4app、初页、maka等" class="headerlink" title="code4ui、code4app、初页、maka等"></a>code4ui、code4app、初页、maka等</h3><ul>
<li><p>前端dom操作即使刷新前端页面</p>
</li>
<li><p>根据dom操作生成组件config配置保存到db</p>
</li>
<li><p>根据config配置使用r.js或webpack打包</p>
</li>
<li><p>发布打包后输出文件</p>
</li>
</ul>
<h3 id="css3动画"><a href="#css3动画" class="headerlink" title="css3动画"></a>css3动画</h3><ul>
<li><p>transform</p>
</li>
<li><p>animation</p>
</li>
<li><p>transiction</p>
</li>
<li><p>3D加速与动画加速</p>
</li>
<li><p>动画库</p>
</li>
<li><p>缓动函数速查表： <a href="http://www.xuanfengge.com/easeing/easeing/" target="_blank" rel="external">http://www.xuanfengge.com/easeing/easeing/</a></p>
</li>
<li><p>Ceaser： <a href="http://xuanfengge.com/easeing/ceaser/" target="_blank" rel="external">http://xuanfengge.com/easeing/ceaser/</a></p>
</li>
<li><p>cubic-bezier： <a href="http://cubic-bezier.com/" target="_blank" rel="external">http://cubic-bezier.com/</a></p>
</li>
</ul>
<h3 id="css网格布局"><a href="#css网格布局" class="headerlink" title="css网格布局"></a>css网格布局</h3><ul>
<li>susy</li>
<li><p>Responsive Grid System</p>
</li>
<li><p>Fluid 960 Grid(adaptjs)</p>
</li>
<li><p>Simple Grid</p>
</li>
</ul>
<h3 id="搜索引擎与前端SEO"><a href="#搜索引擎与前端SEO" class="headerlink" title="搜索引擎与前端SEO"></a>搜索引擎与前端SEO</h3><ul>
<li><p>tdk优化</p>
</li>
<li><p>页面内容优化</p>
</li>
<li><p>唯一的H1标题</p>
</li>
<li><p>img设置alt属性</p>
</li>
<li><p>nofollow</p>
</li>
<li><p>url优化</p>
</li>
<li><p>统一链接</p>
</li>
<li><p>301跳转</p>
</li>
<li><p>canonical</p>
</li>
<li><p>robot优化</p>
</li>
<li><p>robots.txt</p>
</li>
<li><p>meta robots</p>
</li>
<li><p>sitemap</p>
</li>
<li><p>SEO工具</p>
</li>
<li><p>各种站长工具等</p>
</li>
</ul>
<h3 id="浏览器缓存种类，resources-webSQL-indexDB-localstorage-cookie-app-cache-cache-storage"><a href="#浏览器缓存种类，resources-webSQL-indexDB-localstorage-cookie-app-cache-cache-storage" class="headerlink" title="浏览器缓存种类，resources,webSQL,indexDB, localstorage,cookie,app cache,cache storage"></a>浏览器缓存种类，resources,webSQL,indexDB, localstorage,cookie,app cache,cache storage</h3><ul>
<li><p>store.js、cookie.js</p>
<h3 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h3></li>
<li><p>bootstrap、jqwidgets、semantic ui、amaze ui</p>
</li>
<li><p>微信手Q ui: frozenui、weui、blend ui</p>
</li>
<li><p>extjs、echart图表ui</p>
</li>
</ul>
<h2 id="五、native-hybrid-桌面开发"><a href="#五、native-hybrid-桌面开发" class="headerlink" title="五、native/hybrid/桌面开发"></a>五、native/hybrid/桌面开发</h2><h3 id="ionic移动开发方案"><a href="#ionic移动开发方案" class="headerlink" title="ionic移动开发方案"></a>ionic移动开发方案</h3><ul>
<li><p>运行架构</p>
</li>
<li><p>hybrid混合开发</p>
</li>
<li><p>cordova交互</p>
</li>
<li><p>离线包更新</p>
</li>
<li><p>性能瓶颈</p>
</li>
</ul>
<h3 id="nativescript移动开发方案"><a href="#nativescript移动开发方案" class="headerlink" title="nativescript移动开发方案"></a>nativescript移动开发方案</h3><h3 id="react-Native移动开发方案"><a href="#react-Native移动开发方案" class="headerlink" title="react Native移动开发方案"></a>react Native移动开发方案</h3><ul>
<li><p>运行架构：js引擎</p>
</li>
<li><p>性能缺陷与内存泄露</p>
</li>
<li><p>更新机制</p>
</li>
<li><p>使用场景</p>
</li>
</ul>
<h3 id="android-ios原生开发与框架"><a href="#android-ios原生开发与框架" class="headerlink" title="android/ios原生开发与框架"></a>android/ios原生开发与框架</h3><ul>
<li><p>java</p>
</li>
<li><p>oc、swift</p>
</li>
<li><p>web与native交互</p>
</li>
<li><p>屏幕旋转</p>
</li>
<li><p>摇一摇</p>
</li>
<li><p>录像，拍照，选取本地图片</p>
</li>
<li><p>打电话，发短信</p>
</li>
<li><p>电池电量</p>
</li>
<li><p>地理位置</p>
</li>
<li><p>日期选择</p>
</li>
<li><p>开启硬件加速</p>
</li>
</ul>
<h3 id="桌面应用开发"><a href="#桌面应用开发" class="headerlink" title="桌面应用开发"></a>桌面应用开发</h3><ul>
<li><p>nodewebkit</p>
</li>
<li><p>atom-shell(后改名为electron)</p>
</li>
<li><p>网易Hex</p>
</li>
<li><p>pomelo(游戏服务器框架)</p>
</li>
<li><p>react desktop</p>
</li>
<li><p>appjs:appjs.com</p>
</li>
</ul>
<h2 id="六、前端-H5优化-另一个图已给出"><a href="#六、前端-H5优化-另一个图已给出" class="headerlink" title="六、前端/H5优化(另一个图已给出)"></a>六、前端/H5优化(另一个图已给出)</h2><h3 id="yslow、pagespeed"><a href="#yslow、pagespeed" class="headerlink" title="yslow、pagespeed"></a>yslow、pagespeed</h3><h3 id="移动web性能优化"><a href="#移动web性能优化" class="headerlink" title="移动web性能优化"></a>移动web性能优化</h3><ul>
<li><p>手机浏览器”省流量”原理</p>
</li>
<li><p>增量更新原理及注意事项</p>
</li>
<li><p>本地存储的应用</p>
</li>
<li><p>加载优化</p>
</li>
<li><p>图片优化</p>
</li>
<li><p>单页面及路由实现</p>
</li>
<li><p>业内著名站点案例分析</p>
</li>
</ul>
<h2 id="七、全栈-全端开发"><a href="#七、全栈-全端开发" class="headerlink" title="七、全栈/全端开发"></a>七、全栈/全端开发</h2><p>###　express/node club + mongodb、thinkjs等框架</p>
<h3 id="node-js直出"><a href="#node-js直出" class="headerlink" title="node.js直出"></a>node.js直出</h3><h3 id="实时web开发，meteo-express-io"><a href="#实时web开发，meteo-express-io" class="headerlink" title="实时web开发，meteo/express.io"></a>实时web开发，meteo/express.io</h3><h3 id="MEAN-mongodb-express-angular-nodejs"><a href="#MEAN-mongodb-express-angular-nodejs" class="headerlink" title="MEAN(mongodb/express/angular/nodejs)"></a>MEAN(mongodb/express/angular/nodejs)</h3><h3 id="http与http2协议、bigpipe、pipeline"><a href="#http与http2协议、bigpipe、pipeline" class="headerlink" title="http与http2协议、bigpipe、pipeline"></a>http与http2协议、bigpipe、pipeline</h3><h3 id="离线缓存，cookie、localstorage、indexdb"><a href="#离线缓存，cookie、localstorage、indexdb" class="headerlink" title="离线缓存，cookie、localstorage、indexdb"></a>离线缓存，cookie、localstorage、indexdb</h3><h3 id="cdn与dns"><a href="#cdn与dns" class="headerlink" title="cdn与dns"></a>cdn与dns</h3><ul>
<li><p>动态域名加速</p>
</li>
<li><p>cdn原理与cdn combo</p>
</li>
</ul>
<h2 id="八、研究实验"><a href="#八、研究实验" class="headerlink" title="八、研究实验"></a>八、研究实验</h2><h3 id="WebAssembly、webTRC、typescript"><a href="#WebAssembly、webTRC、typescript" class="headerlink" title="WebAssembly、webTRC、typescript"></a>WebAssembly、webTRC、typescript</h3><h3 id="Material-design规范的前端框架"><a href="#Material-design规范的前端框架" class="headerlink" title="Material design规范的前端框架"></a>Material design规范的前端框架</h3><ul>
<li><p>交互动效库</p>
<h3 id="AMP-HTML规范"><a href="#AMP-HTML规范" class="headerlink" title="AMP-HTML规范"></a>AMP-HTML规范</h3></li>
<li><p>使用受限HTML以及缓存技术来提高移动网络中静态内容的性能</p>
</li>
<li><p>添加自定义的元素代替禁用掉的元素：amp-audio, amp-img、amp-video等</p>
</li>
</ul>
<h2 id="九、数据分析与监控"><a href="#九、数据分析与监控" class="headerlink" title="九、数据分析与监控"></a>九、数据分析与监控</h2><ul>
<li><p>badjs数据上报</p>
</li>
<li><p>捕获错误两种方法：onerror、try-catch。抽样上报，先onerror统计语法错误，如果是script error，再使用tryjs。</p>
</li>
<li><p>后台统计方法、不同业务接入体系、抽样统计</p>
</li>
<li><p>onerror:可以捕捉语法错误和运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；当前页面执行的js脚本出错都会捕捉到；跨域的资源需要特殊头部支持。</p>
</li>
<li><p>try-catch:无法捕捉语法错误，只能捕捉运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；需要借助工具把function块以及文件块加入try,catch，可以在这个阶段打入更多的静态信息。</p>
</li>
</ul>
<h3 id="点击热力图clickHeat、heatMap"><a href="#点击热力图clickHeat、heatMap" class="headerlink" title="点击热力图clickHeat、heatMap"></a>点击热力图clickHeat、heatMap</h3><h3 id="js加载失败优化方案"><a href="#js加载失败优化方案" class="headerlink" title="js加载失败优化方案"></a>js加载失败优化方案</h3><ul>
<li><p>失败重发机制</p>
</li>
<li><p>加载源域名服务器文件</p>
</li>
<li><p>https反劫持</p>
</li>
</ul>
<h3 id="百度alog数据上报"><a href="#百度alog数据上报" class="headerlink" title="百度alog数据上报"></a>百度alog数据上报</h3><h2 id="十、其它软技能"><a href="#十、其它软技能" class="headerlink" title="十、其它软技能"></a>十、其它软技能</h2><h3 id="axure-原型图设计"><a href="#axure-原型图设计" class="headerlink" title="axure 原型图设计"></a>axure 原型图设计</h3><h3 id="xmind脑图管理"><a href="#xmind脑图管理" class="headerlink" title="xmind脑图管理"></a>xmind脑图管理</h3><h3 id="效率管理"><a href="#效率管理" class="headerlink" title="效率管理"></a>效率管理</h3><h3 id="can-i-use、github"><a href="#can-i-use、github" class="headerlink" title="can i use、github"></a>can i use、github</h3><h3 id="知识管理-总结分享"><a href="#知识管理-总结分享" class="headerlink" title="知识管理/总结分享"></a>知识管理/总结分享</h3><h3 id="产品思维与技能"><a href="#产品思维与技能" class="headerlink" title="产品思维与技能"></a>产品思维与技能</h3><h2 id="十一、前端技术网站"><a href="#十一、前端技术网站" class="headerlink" title="十一、前端技术网站"></a>十一、前端技术网站</h2><h3 id="技术社区"><a href="#技术社区" class="headerlink" title="技术社区"></a>技术社区</h3><ul>
<li><p>w3c tech、w3c plus、w3 help</p>
</li>
<li><p>div.io、nodeParty</p>
</li>
<li><p>稀土掘金、前端早读课</p>
</li>
<li><p>alloyteam、html5基地</p>
</li>
<li><p>W3 help</p>
</li>
</ul>
<h3 id="行业会议"><a href="#行业会议" class="headerlink" title="行业会议"></a>行业会议</h3><ul>
<li><p>segmentfault会议</p>
</li>
<li><p>深js、杭js</p>
</li>
<li><p>GMIC(全球移动互联网大会)</p>
</li>
<li><p>D2、webrebuild</p>
</li>
<li><p>infoQ内容、Qcon、velocity</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信订座系统项目总结]]></title>
      <url>http://yoursite.com/2016/03/12/%E5%BE%AE%E4%BF%A1%E8%AE%A2%E5%BA%A7%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="微信订座系统项目总结"><a href="#微信订座系统项目总结" class="headerlink" title="微信订座系统项目总结"></a>微信订座系统项目总结</h1><h2 id="第一次移动端前端项目心得分享"><a href="#第一次移动端前端项目心得分享" class="headerlink" title="第一次移动端前端项目心得分享"></a>第一次移动端前端项目心得分享</h2><h3 id="这次项目，遇到了许多问题，也学到了许多，在这里分享一下心得"><a href="#这次项目，遇到了许多问题，也学到了许多，在这里分享一下心得" class="headerlink" title="这次项目，遇到了许多问题，也学到了许多，在这里分享一下心得  "></a>这次项目，遇到了许多问题，也学到了许多，在这里分享一下心得  <a id="more"></a></h3><h3 id="一．项目整体流程"><a href="#一．项目整体流程" class="headerlink" title="一．项目整体流程"></a>一．项目整体流程</h3><pre><code>1. 分析用户需求，产品功能
2. 设计图材料
3. 业务逻辑
4. 分工合作
5. 提交， 不断完善，修复bug
</code></pre><h3 id="二．遇到的问题及解决办法"><a href="#二．遇到的问题及解决办法" class="headerlink" title="二．遇到的问题及解决办法"></a>二．遇到的问题及解决办法</h3><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分:"></a>html部分:</h4><pre><code>1. html5新标签，新属性应用（input的placeholder属性，type=”date”）；
2. 命名规则
</code></pre><h4 id="css部分："><a href="#css部分：" class="headerlink" title="css部分："></a>css部分：</h4><pre><code>1. 设计图各部分尺寸比例，ps测量；
2. 移动端适配，meta标签使用，视口等理解；
3. 移动端对flex box布局方式的支持，考虑用浮动布局；
4. 图片大小压缩问题，宽度设置，高度自适应;
5. 苹果手机自动缩放屏幕问题，禁止用户缩放;
</code></pre><h4 id="js部分："><a href="#js部分：" class="headerlink" title="js部分："></a>js部分：</h4><pre><code>1. 用闭包解决js无块级作用域的影响；
2. 自定义特性不会自动添加到dom对象属性；
3. 自定义dom对象属性也不会添加到特性；
4. 与后台数据对接，封装函数，做好接口；
</code></pre><h3 id="三．思考改进"><a href="#三．思考改进" class="headerlink" title="三．思考改进"></a>三．思考改进</h3><pre><code>1. 命名规范
2. W3C标准
3. 使用框架开发，bootstrap或者jquery mobile
4. 简化逻辑，性能优化
5. 代码可维护性
6. 开发效率
</code></pre><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><pre><code>1. 图片和其他非代码文件放在单独的文件夹
2. 变量声明和函数声明写在最前面，以增加代码的可维护性
3. 使用动态改变元素的class来改变元素的样式
4. 将雪碧图放到一个数组里，循环适用于多个元素
5. html5在DOM上的扩展，自定义特性可以通过元素的dataset属性来访问自定义特性对于于DOM对象中的属性
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[snake game]]></title>
      <url>http://yoursite.com/2016/03/12/snake-game/</url>
      <content type="html"><![CDATA[<h1 id="javascript原生贪吃蛇游戏"><a href="#javascript原生贪吃蛇游戏" class="headerlink" title="javascript原生贪吃蛇游戏"></a>javascript原生贪吃蛇游戏</h1><a id="more"></a>
<h4 id="附上三张效果图"><a href="#附上三张效果图" class="headerlink" title="附上三张效果图"></a>附上三张效果图</h4><p><img src="http://7xsi10.com2.z0.glb.clouddn.com/psb%20%282%29.jpg" alt="snake1"><br><img src="http://7xsi10.com2.z0.glb.clouddn.com/psb%20%281%29.jpg" alt="snake2"><br><img src="http://7xsi10.com2.z0.glb.clouddn.com/psb.jpg" alt="snake3"></p>
<h3 id="源码已经托管到我的github，点击进入我的github"><a href="#源码已经托管到我的github，点击进入我的github" class="headerlink" title="源码已经托管到我的github，点击进入我的github"></a>源码已经托管到我的github，点击进入<a href="https://github.com/laoqiren" target="_blank" rel="external">我的github</a></h3>]]></content>
    </entry>
    
  
  
</search>
